#!/usr/bin/env python
# -*- coding: utf-8 -*-

import json
import random
import logging
import traceback
import gzip
import struct
from typing import Dict, Any, Optional, Union
from io import BytesIO

from core.PluginManager import Plugin
from core.onebot.api import get_onebot_api, run_async_api

logger = logging.getLogger('ElainaBot.plugins.packet')


# ==================== ProtoBuf 编解码器 ====================

class Writer:
    def __init__(self):
        self.buf = BytesIO()
    
    @classmethod
    def create(cls):
        return cls()
    
    def uint32(self, value: int):
        while value > 0x7f:
            self.buf.write(bytes([(value & 0x7f) | 0x80]))
            value >>= 7
        self.buf.write(bytes([value & 0x7f]))
        return self
    
    def int32(self, value: int):
        if value < 0:
            value = (1 << 32) + value
        return self.uint32(value)
    
    def int64(self, value: Union[int, str]):
        if isinstance(value, str):
            value = int(value)
        if value < 0:
            value = (1 << 64) + value
        return self.uint32(value)
    
    def string(self, value: str):
        data = value.encode('utf-8')
        self.uint32(len(data))
        self.buf.write(data)
        return self
    
    def bool(self, value: bool):
        return self.uint32(1 if value else 0)
    
    def bytes(self, value: bytes):
        self.uint32(len(value))
        self.buf.write(value)
        return self
    
    def fixed32(self, value: int):
        self.buf.write(struct.pack('<I', value))
        return self
    
    def fixed64(self, value: int):
        self.buf.write(struct.pack('<Q', value))
        return self
    
    def finish(self) -> bytes:
        return self.buf.getvalue()


class Reader:
    def __init__(self, data: bytes):
        self.buf = data
        self.pos = 0
        self.len = len(data)
    
    @classmethod
    def create(cls, data: bytes):
        return cls(data)
    
    def uint32(self) -> int:
        result = 0
        shift = 0
        while True:
            if self.pos >= self.len:
                break
            byte_val = self.buf[self.pos]
            self.pos += 1
            result |= (byte_val & 0x7f) << shift
            if not (byte_val & 0x80):
                break
            shift += 7
        return result
    
    def int64(self):
        value = self.uint32()
        if value > 0x7fffffffffffffff:
            value = value - (1 << 64)
        return value
    
    def fixed64(self):
        data = self.buf[self.pos:self.pos + 8]
        self.pos += 8
        return struct.unpack('<Q', data)[0]
    
    def bytes(self) -> bytes:
        length = self.uint32()
        data = self.buf[self.pos:self.pos + length]
        self.pos += length
        return data
    
    def fixed32(self) -> int:
        data = self.buf[self.pos:self.pos + 4]
        self.pos += 4
        return struct.unpack('<I', data)[0]


class Protobuf:
    def __init__(self):
        self.Writer = Writer
        self.Reader = Reader
    
    def encode(self, obj):
        writer = self.Writer.create()
        for tag in sorted(map(int, obj.keys())):
            value = obj[tag]
            self._encode(writer, tag, value)
        return writer.finish()
    
    def _encode(self, writer, tag, value):
        if value is None:
            return
        
        if isinstance(value, int) and not isinstance(value, bool):
            writer.uint32((tag << 3) | 0).int32(value)
        elif isinstance(value, int) and abs(value) > 2147483647:
            writer.uint32((tag << 3) | 0).int64(str(value))
        elif isinstance(value, str):
            writer.uint32((tag << 3) | 2).string(value)
        elif isinstance(value, bool):
            writer.uint32((tag << 3) | 0).bool(value)
        elif isinstance(value, (dict, list, bytes, bytearray)):
            if isinstance(value, (bytes, bytearray)):
                writer.uint32((tag << 3) | 2).bytes(bytes(value))
            elif isinstance(value, list):
                for item in value:
                    self._encode(writer, tag, item)
            elif value is None:
                pass
            elif isinstance(value, dict):
                nested_buffer = self.encode(value)
                writer.uint32((tag << 3) | 2).bytes(nested_buffer)
        else:
            raise Exception(f"Unsupported type: {type(value).__name__}")
    
    def decode(self, buffer):
        if isinstance(buffer, str):
            buffer = bytes.fromhex(buffer)
        
        result = {}
        reader = self.Reader.create(buffer)
        
        while reader.pos < reader.len:
            k = reader.uint32()
            tag = k >> 3
            wire_type = k & 0b111
            
            value = None
            
            if wire_type == 0:
                value = self.long2int(reader.int64())
            elif wire_type == 1:
                value = self.long2int(reader.fixed64())
            elif wire_type == 2:
                value = reader.bytes()
                try:
                    value = self.decode(value)
                except:
                    try:
                        decoded = value.decode('utf-8')
                        re_encoded = decoded.encode('utf-8')
                        if all(a == b for a, b in zip(re_encoded, value)):
                            value = decoded
                    except:
                        pass
            elif wire_type == 5:
                value = reader.fixed32()
            else:
                raise Exception(f"Unsupported wire type: {wire_type}")
            
            if tag in result:
                if isinstance(result[tag], list):
                    result[tag].append(value)
                else:
                    result[tag] = [result[tag], value]
            else:
                result[tag] = value
        
        return result
    
    def long2int(self, long):
        if isinstance(long, int):
            if -9007199254740991 <= long <= 9007199254740991:
                return long
            else:
                return long
        return long


pb = Protobuf()


# ==================== Packet 辅助类 ====================

class PacketHelper:
    @staticmethod
    def random_uint() -> int:
        return random.randint(0, 0xFFFFFFFF)
    
    @staticmethod
    def process_json(data: Union[str, dict]) -> dict:
        if isinstance(data, str):
            try:
                data = json.loads(data)
            except json.JSONDecodeError as e:
                logger.error(f"JSON 解析失败: {str(e)}")
                return {}
        return PacketHelper._process_json_recursive(data)
    
    @staticmethod
    def _process_json_recursive(obj: Any, path: list = None) -> Any:
        if path is None:
            path = []
        
        if isinstance(obj, bytes):
            return obj
        elif isinstance(obj, list):
            return [PacketHelper._process_json_recursive(item, path + [str(i+1)]) for i, item in enumerate(obj)]
        elif isinstance(obj, dict):
            result = {}
            for key, value in obj.items():
                try:
                    num_key = int(key)
                except ValueError:
                    logger.warning(f"键不是有效的整数: {key}")
                    continue
                
                current_path = path + [key]
                
                if isinstance(value, dict):
                    result[num_key] = PacketHelper._process_json_recursive(value, current_path)
                elif isinstance(value, list):
                    result[num_key] = [PacketHelper._process_json_recursive(item, current_path + [str(i+1)]) 
                                      for i, item in enumerate(value)]
                elif isinstance(value, str):
                    if value.startswith("hex->"):
                        hex_str = value[5:]
                        if PacketHelper._is_hex_string(hex_str):
                            result[num_key] = bytes.fromhex(hex_str)
                        else:
                            result[num_key] = value
                    else:
                        result[num_key] = value
                else:
                    result[num_key] = value
            return result
        else:
            return obj
    
    @staticmethod
    def _is_hex_string(s: str) -> bool:
        if len(s) % 2 != 0:
            return False
        try:
            bytes.fromhex(s)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def json_dumps_with_bytes(obj: Any) -> str:
        def default(o):
            if isinstance(o, bytes):
                return f"hex->{o.hex()}"
            raise TypeError(f"Object of type {type(o).__name__} is not JSON serializable")
        return json.dumps(obj, default=default, indent=2, ensure_ascii=False)


# ==================== Packet 发送器 ====================

class PacketSender:
    def __init__(self, event):
        self.event = event
        self.api = event.api
    
    async def send_packet(self, cmd: str, content: Union[dict, str]) -> Optional[dict]:
        try:
            if isinstance(content, str):
                content = json.loads(content)
            
            processed = PacketHelper.process_json(content)
            data_bytes = pb.encode(processed)
            data_hex = data_bytes.hex()
            
            result = await self.api.call_api('send_packet', cmd=cmd, data=data_hex)
            
            if result and isinstance(result, dict):
                response_data = result.get('data')
                
                if isinstance(response_data, str) and response_data:
                    try:
                        decoded = pb.decode(response_data)
                        return decoded
                    except Exception as e:
                        logger.error(f"解码响应失败: {str(e)}")
                        return result
                elif isinstance(response_data, dict) and response_data:
                    return response_data
            
            return result
        except Exception as e:
            logger.error(f"发送数据包失败: {str(e)}")
            logger.error(traceback.format_exc())
            return None
    
    async def send_elem(self, content: Union[dict, str]) -> Optional[dict]:
        try:
            if isinstance(content, str):
                content = json.loads(content)
            
            processed_content = PacketHelper.process_json(content)
            
            target_id = self.event.group_id if self.event.is_group else self.event.user_id
            packet = {
                1: {
                    (2 if self.event.is_group else 1): {
                        1: int(target_id)
                    }
                },
                2: {
                    1: 1,
                    2: 0,
                    3: 0
                },
                3: {
                    1: {
                        2: processed_content
                    }
                },
                4: PacketHelper.random_uint(),
                5: PacketHelper.random_uint()
            }
            
            return await self.send_packet('MessageSvc.PbSendMsg', packet)
        except Exception as e:
            logger.error(f"发送元素失败: {str(e)}")
            return None
    
    async def send_long(self, content: Union[dict, str]) -> Optional[dict]:
        try:
            resid = await self.upload_long(content)
            if not resid:
                logger.error("上传长消息失败")
                return None
            
            elem = {
                37: {
                    6: 1,
                    7: resid,
                    17: 0,
                    19: {
                        15: 0,
                        31: 0,
                        41: 0
                    }
                }
            }
            
            return await self.send_elem(elem)
        except Exception as e:
            logger.error(f"发送长消息失败: {str(e)}")
            return None
    
    async def upload_long(self, content: Union[dict, str]) -> Optional[str]:
        try:
            if isinstance(content, str):
                content = json.loads(content)
            
            processed_content = PacketHelper.process_json(content)
            
            data = {
                2: {
                    1: "MultiMsg",
                    2: {
                        1: [{
                            3: {
                                1: {
                                    2: processed_content
                                }
                            }
                        }]
                    }
                }
            }
            
            data_bytes = pb.encode(data)
            compressed_data = gzip.compress(data_bytes)
            
            target_id = int(self.event.group_id if self.event.is_group else self.event.user_id)
            packet = {
                2: {
                    1: 3 if self.event.is_group else 1,
                    2: {
                        2: target_id
                    },
                    3: str(target_id),
                    4: compressed_data
                },
                15: {
                    1: 4,
                    2: 2,
                    3: 9,
                    4: 0
                }
            }
            
            resp = await self.send_packet('trpc.group.long_msg_interface.MsgService.SsoSendLongMsg', packet)
            
            if resp and isinstance(resp, dict):
                resid = resp.get("2", {}).get("3")
                return resid
            
            return None
        except Exception as e:
            logger.error(f"上传长消息失败: {str(e)}")
            return None
    
    async def get_msg(self, message_id: Union[str, int], real_seq: Optional[str] = None) -> Optional[dict]:
        try:
            if not real_seq:
                msg_info = await self.api.get_msg(message_id)
                
                if not msg_info:
                    logger.error("获取消息失败：API 无响应")
                    return None
                
                if isinstance(msg_info, dict):
                    if msg_info.get('retcode') == 0:
                        real_seq = msg_info.get('data', {}).get('real_seq')
                    else:
                        real_seq = msg_info.get('real_seq')
                
                if not real_seq:
                    logger.error("未找到 real_seq")
                    return None
            
            seq = int(real_seq)
            
            packet = {
                1: {
                    1: int(self.event.group_id),
                    2: seq,
                    3: seq
                },
                2: True
            }
            
            return await self.send_packet('trpc.msg.register_proxy.RegisterProxy.SsoGetGroupMsg', packet)
        except Exception as e:
            logger.error(f"获取消息失败: {str(e)}")
            return None


# ==================== Packet 插件 ====================

class PacketPlugin(Plugin):
    priority = 1000
    
    @staticmethod
    def get_regex_handlers():
        return {
            r'^#?(api|API)\s*\{': {'handler': 'handle_api', 'owner_only': True},
            r'^#?(pb|PB)\s*\{': {'handler': 'handle_pb', 'owner_only': True},
            r'^#?(pbl|PBL)\s*\{': {'handler': 'handle_pbl', 'owner_only': True},
            r'^#?(raw|RAW)\s*\{': {'handler': 'handle_raw', 'owner_only': True},
            r'^#?取$': 'handle_get_msg'
        }
    
    @staticmethod
    def handle_api(event):
        try:
            content = event.content
            content = content[4:].strip() if content.lower().startswith('#api') else content[3:].strip()
            
            lines = content.split('\n', 1)
            if len(lines) < 2:
                brace_pos = content.find('{')
                if brace_pos == -1:
                    event.reply("格式错误，请使用: #api <action>\\n<json>")
                    return True
                action = content[:brace_pos].strip()
                params_str = content[brace_pos:]
            else:
                action = lines[0].strip()
                params_str = lines[1].strip()
            
            try:
                params = json.loads(params_str)
            except json.JSONDecodeError as e:
                event.reply(f"JSON 解析失败: {str(e)}")
                return True
            
            result = run_async_api(event.api.call_api(action, **params))
            result_str = json.dumps(result, indent=2, ensure_ascii=False)
            event.reply(f"API 调用结果:\n{result_str}")
            
            return True
        except Exception as e:
            logger.error(f"API 调用失败: {str(e)}")
            event.reply(f"处理失败: {str(e)}")
            return True
    
    @staticmethod
    def handle_pb(event):
        try:
            content = event.content
            content = content[3:].strip() if content.lower().startswith('#pb') else content[2:].strip()
            
            sender = PacketSender(event)
            result = run_async_api(sender.send_elem(content))
            
            if result:
                event.reply("✅ 发送成功")
            else:
                event.reply("❌ 发送失败")
            
            return True
        except Exception as e:
            logger.error(f"PB 发送失败: {str(e)}")
            event.reply(f"处理失败: {str(e)}")
            return True
    
    @staticmethod
    def handle_pbl(event):
        try:
            content = event.content
            content = content[4:].strip() if content.lower().startswith('#pbl') else content[3:].strip()
            
            sender = PacketSender(event)
            result = run_async_api(sender.send_long(content))
            
            if result:
                event.reply("✅ 长消息发送成功")
            else:
                event.reply("❌ 发送失败")
            
            return True
        except Exception as e:
            logger.error(f"PBL 发送失败: {str(e)}")
            event.reply(f"处理失败: {str(e)}")
            return True
    
    @staticmethod
    def handle_raw(event):
        try:
            content = event.content
            content = content[4:].strip() if content.lower().startswith('#raw') else content[3:].strip()
            
            lines = content.split('\n', 1)
            if len(lines) < 2:
                brace_pos = content.find('{')
                if brace_pos == -1:
                    event.reply("格式错误，请使用: #raw <cmd>\\n<json>")
                    return True
                cmd = content[:brace_pos].strip()
                packet_str = content[brace_pos:]
            else:
                cmd = lines[0].strip()
                packet_str = lines[1].strip()
            
            sender = PacketSender(event)
            result = run_async_api(sender.send_packet(cmd, packet_str))
            
            if result:
                result_str = PacketHelper.json_dumps_with_bytes(result)
                event.reply(f"✅ 发送成功\n响应:\n{result_str}")
            else:
                event.reply("❌ 发送失败")
            
            return True
        except Exception as e:
            logger.error(f"RAW 发送失败: {str(e)}")
            event.reply(f"处理失败: {str(e)}")
            return True
    
    @staticmethod
    def handle_get_msg(event):
        try:
            if not event.is_group:
                event.reply("该功能仅支持群聊")
                return True
            
            reply_id = None
            for segment in event.message:
                if isinstance(segment, dict) and segment.get('type') == 'reply':
                    reply_id = segment.get('data', {}).get('id')
                    break
            
            if not reply_id:
                event.reply("请回复要获取的消息")
                return True
            
            real_seq = None
            try:
                from function.log_db import get_log_from_db
                db_msg = get_log_from_db('received', message_id=reply_id)
                if db_msg:
                    real_seq = db_msg.get('real_seq')
            except Exception as e:
                logger.warning(f"从数据库获取 real_seq 失败: {str(e)}")
            
            sender = PacketSender(event)
            msg_info = run_async_api(event.api.get_msg(reply_id))
            
            msg_data = {}
            if msg_info:
                if isinstance(msg_info, dict):
                    if msg_info.get('retcode') == 0:
                        msg_data = msg_info.get('data', {})
                        if not real_seq:
                            real_seq = msg_data.get('real_seq')
                    else:
                        msg_data = msg_info
                        if not real_seq:
                            real_seq = msg_info.get('real_seq')
            
            pb_data = None
            if real_seq:
                pb_data = run_async_api(sender.get_msg(reply_id, real_seq=real_seq))
            
            # 构建三条消息内容
            # 第一条：消息信息
            msg_info_parts = ["=== 消息信息 ===", f"消息ID: {reply_id}"]
            if real_seq:
                msg_info_parts.append(f"Real Seq: {real_seq}")
            msg_info_parts.append(f"消息类型: {msg_data.get('message_type', 'unknown')}")
            
            sender_info = msg_data.get('sender', {})
            sender_id = sender_info.get('user_id', 'unknown') if isinstance(sender_info, dict) else 'unknown'
            msg_info_parts.append(f"发送者: {sender_id}")
            msg_info_content = '\n'.join(msg_info_parts)
            
            # 第二条：OneBot 消息数组
            message_array = msg_data.get('message', [])
            onebot_content = "=== OneBot 消息数组 ===\n" + json.dumps(message_array, indent=2, ensure_ascii=False)
            
            # 第三条：ProtoBuf 数据
            if pb_data:
                pb_content = "=== ProtoBuf 完整数据 ===\n" + PacketHelper.json_dumps_with_bytes(pb_data)
            else:
                pb_content = "=== ProtoBuf 完整数据 ===\n⚠️ 未找到 real_seq，无法获取 PB 数据"
            
            # 构建合并转发消息
            bot_qq = event.self_id
            bot_name = "Bot"
            
            nodes = [
                {
                    "type": "node",
                    "data": {
                        "name": bot_name,
                        "uin": str(bot_qq),
                        "content": msg_info_content
                    }
                },
                {
                    "type": "node",
                    "data": {
                        "name": bot_name,
                        "uin": str(bot_qq),
                        "content": onebot_content
                    }
                },
                {
                    "type": "node",
                    "data": {
                        "name": bot_name,
                        "uin": str(bot_qq),
                        "content": pb_content
                    }
                }
            ]
            
            # 发送合并转发
            result = run_async_api(event.api.send_group_forward_msg(event.group_id, nodes))
            
            if not result or result.get('retcode') != 0:
                event.reply("❌ 发送合并转发失败")
            
            return True
        except Exception as e:
            logger.error(f"获取消息失败: {str(e)}")
            logger.error(traceback.format_exc())
            event.reply(f"获取消息失败: {str(e)}")
            return True
