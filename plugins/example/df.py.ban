#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""è”åˆä»£å‘æ’ä»¶ - æ‹¦æˆªæ‰€æœ‰æ’ä»¶å›å¤å¹¶è½¬å‘ç»™å®˜æ–¹æœºå™¨äºº"""

import httpx
import time
import json
import os
import logging
import struct
import gzip
import random
from typing import Optional, Dict, Any
from io import BytesIO
from core.PluginManager import Plugin
from core.MessageEvent import Message, MessageSegment
from core.onebot.api import get_onebot_api, run_async_api

logger = logging.getLogger('ElainaBot.ForwardBridge')


# ==================== ProtoBuf ç¼–è§£ç å™¨ ====================

class Writer:
    def __init__(self):
        self.buf = BytesIO()
    
    @classmethod
    def create(cls):
        return cls()
    
    def uint32(self, value: int):
        while value > 0x7f:
            self.buf.write(bytes([(value & 0x7f) | 0x80]))
            value >>= 7
        self.buf.write(bytes([value & 0x7f]))
        return self
    
    def int32(self, value: int):
        if value < 0:
            value = (1 << 32) + value
        return self.uint32(value)
    
    def int64(self, value):
        if isinstance(value, str):
            value = int(value)
        if value < 0:
            value = (1 << 64) + value
        return self.uint32(value)
    
    def string(self, value: str):
        data = value.encode('utf-8')
        self.uint32(len(data))
        self.buf.write(data)
        return self
    
    def bool(self, value: bool):
        return self.uint32(1 if value else 0)
    
    def bytes(self, value: bytes):
        self.uint32(len(value))
        self.buf.write(value)
        return self
    
    def fixed32(self, value: int):
        self.buf.write(struct.pack('<I', value))
        return self
    
    def fixed64(self, value: int):
        self.buf.write(struct.pack('<Q', value))
        return self
    
    def finish(self) -> bytes:
        return self.buf.getvalue()


class Reader:
    def __init__(self, data: bytes):
        self.buf = data
        self.pos = 0
        self.len = len(data)
    
    @classmethod
    def create(cls, data: bytes):
        return cls(data)
    
    def uint32(self) -> int:
        result = 0
        shift = 0
        while True:
            if self.pos >= self.len:
                break
            byte_val = self.buf[self.pos]
            self.pos += 1
            result |= (byte_val & 0x7f) << shift
            if not (byte_val & 0x80):
                break
            shift += 7
        return result
    
    def int64(self):
        value = self.uint32()
        if value > 0x7fffffffffffffff:
            value = value - (1 << 64)
        return value
    
    def fixed64(self):
        data = self.buf[self.pos:self.pos + 8]
        self.pos += 8
        return struct.unpack('<Q', data)[0]
    
    def bytes(self) -> bytes:
        length = self.uint32()
        data = self.buf[self.pos:self.pos + length]
        self.pos += length
        return data
    
    def fixed32(self) -> int:
        data = self.buf[self.pos:self.pos + 4]
        self.pos += 4
        return struct.unpack('<I', data)[0]


class Protobuf:
    def __init__(self):
        self.Writer = Writer
        self.Reader = Reader
    
    def encode(self, obj):
        writer = self.Writer.create()
        for tag in sorted(map(int, obj.keys())):
            value = obj[tag]
            self._encode(writer, tag, value)
        return writer.finish()
    
    def _encode(self, writer, tag, value):
        if value is None:
            return
        
        if isinstance(value, int) and not isinstance(value, bool):
            writer.uint32((tag << 3) | 0).int32(value)
        elif isinstance(value, int) and abs(value) > 2147483647:
            writer.uint32((tag << 3) | 0).int64(str(value))
        elif isinstance(value, str):
            writer.uint32((tag << 3) | 2).string(value)
        elif isinstance(value, bool):
            writer.uint32((tag << 3) | 0).bool(value)
        elif isinstance(value, (dict, list, bytes, bytearray)):
            if isinstance(value, (bytes, bytearray)):
                writer.uint32((tag << 3) | 2).bytes(bytes(value))
            elif isinstance(value, list):
                for item in value:
                    self._encode(writer, tag, item)
            elif value is None:
                pass
            elif isinstance(value, dict):
                nested_buffer = self.encode(value)
                writer.uint32((tag << 3) | 2).bytes(nested_buffer)
        else:
            raise Exception(f"Unsupported type: {type(value).__name__}")
    
    def decode(self, buffer):
        if isinstance(buffer, str):
            buffer = bytes.fromhex(buffer)
        
        result = {}
        reader = self.Reader.create(buffer)
        
        while reader.pos < reader.len:
            k = reader.uint32()
            tag = k >> 3
            wire_type = k & 0b111
            
            value = None
            
            if wire_type == 0:
                value = self.long2int(reader.int64())
            elif wire_type == 1:
                value = self.long2int(reader.fixed64())
            elif wire_type == 2:
                value = reader.bytes()
                try:
                    value = self.decode(value)
                except:
                    try:
                        decoded = value.decode('utf-8')
                        re_encoded = decoded.encode('utf-8')
                        if all(a == b for a, b in zip(re_encoded, value)):
                            value = decoded
                    except:
                        pass
            elif wire_type == 5:
                value = reader.fixed32()
            else:
                raise Exception(f"Unsupported wire type: {wire_type}")
            
            if tag in result:
                if isinstance(result[tag], list):
                    result[tag].append(value)
                else:
                    result[tag] = [result[tag], value]
            else:
                result[tag] = value
        
        return result
    
    def long2int(self, long):
        if isinstance(long, int):
            if -9007199254740991 <= long <= 9007199254740991:
                return long
            else:
                return long
        return long


pb = Protobuf()

logger = logging.getLogger('ElainaBot.ForwardBridge')


class ForwardPlugin(Plugin):
    """è”åˆä»£å‘æ’ä»¶ - ç»Ÿä¸€å¤„ç†æ‰€æœ‰æ’ä»¶çš„æ¶ˆæ¯è½¬å‘å’Œç®¡ç†"""
    
    priority = 0
    
    @staticmethod
    def get_regex_handlers():
        """æ³¨å†Œç®¡ç†æŒ‡ä»¤"""
        return {
            r'^ä»£å‘ç»‘å®š\s+(\d+)(?:\s+(.+))?$': {'handler': 'bind_official_bot', 'master_only': True},
            r'^ä»£å‘çŠ¶æ€$': {'handler': 'check_status', 'master_only': True},
            r'^ä»£å‘è§£ç»‘$': {'handler': 'unbind_official_bot', 'master_only': True},
            r'^ä»£å‘é…ç½®$': {'handler': 'show_config', 'master_only': True},
            r'^ä»£å‘è®¾ç½®\s+(\w+)\s+(.+)$': {'handler': 'set_config', 'master_only': True},
        }
    
    
    @staticmethod
    def get_web_routes():
        """æ³¨å†ŒWebè·¯ç”±"""
        return {
            'path': 'forward_bridge',
            'menu_name': 'è”åˆä»£å‘é…ç½®',
            'menu_icon': 'bi-arrow-left-right',
            'description': 'é…ç½®è”åˆä»£å‘ç³»ç»Ÿ',
            'handler': 'render_page',
            'priority': 50,
            'api_routes': [
                {
                    'path': '/api/forward_bridge/config',
                    'handler': 'api_handle_config',
                    'methods': ['GET', 'POST'],
                    'require_auth': True,
                    'require_token': True
                }
            ]
        }
    
    @classmethod
    def _load_config(cls):
        """åŠ è½½é…ç½®"""
        config_file = os.path.join(os.path.dirname(__file__), 'forward_config.json')
        
        default_config = {
            'enabled': True,
            'official_bot_qq': None,
            'official_bot_api': 'http://127.0.0.1:5001',
            'use_token': False,
            'token': None,
            'auto_activate': True,
            'fallback_to_onebot': True,
            'send_mode': 1,  # 1=æ™®é€šæ¶ˆæ¯, 2=markdownåŸç”Ÿ, 3=AJæ¨¡æ¿, 4=markdownæ¨¡æ¿
            'markdown_template_id': None,  # Markdownæ¨¡æ¿IDï¼ˆå¿…é¡»é…ç½®ï¼‰
            'use_callback_mode': False,  # æ˜¯å¦ä½¿ç”¨å›è°ƒæŒ‰é’®æ¨¡å¼
            'callback_trigger_mode': 1,  # å›è°ƒè§¦å‘æ¨¡å¼: 1=åŸç”Ÿmarkdown+åŸç”ŸæŒ‰é’®, 2=AJæ¨¡æ¿+åŸç”ŸæŒ‰é’®, 3=æ¨¡æ¿markdown+æ¨¡æ¿æŒ‰é’®
            'callback_markdown_template_id': None,  # å›è°ƒæ¨¡å¼çš„markdownæ¨¡æ¿ID
            'callback_button_template_id': None,  # å›è°ƒæ¨¡å¼çš„æŒ‰é’®æ¨¡æ¿ID
            'group_callback_bindings': {}  # ç¾¤ç»„å›è°ƒç»‘å®š {group_id: {event_id, appid, bot_token, ç­‰}}
        }
        
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    default_config.update(config)
        except Exception as e:
            logger.error(f"é…ç½®åŠ è½½å¤±è´¥: {e}")
        
        return default_config
    
    @classmethod
    def _save_config(cls, config):
        """ä¿å­˜é…ç½®"""
        config_file = os.path.join(os.path.dirname(__file__), 'forward_config.json')
        try:
            os.makedirs(os.path.dirname(config_file), exist_ok=True)
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            logger.error(f"é…ç½®ä¿å­˜å¤±è´¥: {e}")
            return False
    
    # ==================== ç®¡ç†æŒ‡ä»¤å¤„ç†æ–¹æ³• ====================
    
    @classmethod
    def bind_official_bot(cls, event):
        """æŒ‡ä»¤ï¼šä»£å‘ç»‘å®š <QQå·> [APIåœ°å€]"""
        try:
            qq = event.matches[0] if event.matches else None
            api = event.matches[1] if len(event.matches) > 1 else None
            
            if not qq:
                event.reply('âŒ è¯·æä¾›å®˜æ–¹æœºå™¨äººQQå·\nç”¨æ³•: ä»£å‘ç»‘å®š <QQå·> [APIåœ°å€/ç«¯å£å·]')
                return True
            
            # å¤„ç†APIåœ°å€
            if not api:
                api = "http://127.0.0.1:5001"
            elif api.isdigit():
                api = f"http://127.0.0.1:{api}"
            elif not api.startswith(('http://', 'https://')):
                api = f"http://{api}"
            
            # ä¿å­˜é…ç½®
            config = cls._load_config()
            config['official_bot_qq'] = qq
            config['official_bot_api'] = api
            
            if cls._save_config(config):
                event.reply(f'âœ… ä»£å‘ç»‘å®šæˆåŠŸ\nâ€¢ å®˜æ–¹æœºå™¨äºº: {qq}\nâ€¢ APIåœ°å€: {api}\n\nä¸‹æ¬¡è§¦å‘æ¶ˆæ¯æ—¶å°†è‡ªåŠ¨æ¿€æ´»')
            else:
                event.reply('âŒ ä¿å­˜é…ç½®å¤±è´¥')
            
            return True
        except Exception as e:
            logger.error(f"ç»‘å®šå¤±è´¥: {e}")
            event.reply(f'âŒ ç»‘å®šå¤±è´¥: {str(e)}')
            return True
    
    @classmethod
    def unbind_official_bot(cls, event):
        """æŒ‡ä»¤ï¼šä»£å‘è§£ç»‘"""
        try:
            config = cls._load_config()
            config['official_bot_qq'] = None
            
            if cls._save_config(config):
                event.reply('âœ… å·²è§£ç»‘å®˜æ–¹æœºå™¨äºº\nç°åœ¨å°†ä½¿ç”¨ OneBot ç›´æ¥å‘é€æ¶ˆæ¯')
            else:
                event.reply('âŒ è§£ç»‘å¤±è´¥')
            return True
        except Exception as e:
            logger.error(f"è§£ç»‘å¤±è´¥: {e}")
            event.reply(f'âŒ è§£ç»‘å¤±è´¥: {str(e)}')
            return True
    
    @classmethod
    def show_config(cls, event):
        """æŒ‡ä»¤ï¼šä»£å‘é…ç½®"""
        try:
            config = cls._load_config()
            
            send_mode = config.get('send_mode', 1)
            mode_names = {1: 'æ™®é€šæ¶ˆæ¯', 2: 'MarkdownåŸç”Ÿ', 3: 'AJæ¨¡æ¿', 4: 'Markdownæ¨¡æ¿'}
            template_id = config.get('markdown_template_id') or 'æœªé…ç½®'
            
            config_text = f"""ğŸ“‹ è”åˆä»£å‘é…ç½®

ğŸ”§ åŸºç¡€é…ç½®:
â€¢ å¯ç”¨çŠ¶æ€: {'âœ… å·²å¯ç”¨' if config.get('enabled') else 'âŒ å·²ç¦ç”¨'}
â€¢ å®˜æ–¹æœºå™¨äºº: {config.get('official_bot_qq') or 'æœªç»‘å®š'}
â€¢ å‘é€æ¨¡å¼: {send_mode} ({mode_names.get(send_mode, 'æœªçŸ¥')})
â€¢ Markdownæ¨¡æ¿ID: {template_id}

âš™ï¸ åŠŸèƒ½é…ç½®:
â€¢ è‡ªåŠ¨æ¿€æ´»: {'âœ… å¯ç”¨' if config.get('auto_activate') else 'âŒ ç¦ç”¨'}
â€¢ å¤±è´¥å›é€€: {'âœ… å¯ç”¨' if config.get('fallback_to_onebot') else 'âŒ ç¦ç”¨'}
"""

            # æ·»åŠ å›è°ƒæ¨¡å¼ä¿¡æ¯
            if config.get('use_callback_mode', False):
                callback_mode = config.get('callback_trigger_mode', 1)
                callback_mode_names = {1: 'åŸç”Ÿmarkdown+åŸç”ŸæŒ‰é’®', 2: 'AJæ¨¡æ¿+åŸç”ŸæŒ‰é’®', 3: 'æ¨¡æ¿markdown+æ¨¡æ¿æŒ‰é’®'}
                config_text += f"\nğŸ”„ å›è°ƒæ¨¡å¼:\nâ€¢ çŠ¶æ€: âœ… å·²å¯ç”¨\nâ€¢ è§¦å‘æ¨¡å¼: {callback_mode_names.get(callback_mode, 'æœªçŸ¥')}\n"
                
                group_bindings = config.get('group_callback_bindings', {})
                if group_bindings:
                    config_text += f"â€¢ å·²ç»‘å®šç¾¤æ•°: {len(group_bindings)}\n"

            config_text += "\nğŸ’¡ ä½¿ç”¨ \"ä»£å‘è®¾ç½® <é…ç½®é¡¹> <å€¼>\" ä¿®æ”¹é…ç½®\n   ä¾‹å¦‚: ä»£å‘è®¾ç½® send_mode 2\n   ä¾‹å¦‚: ä»£å‘è®¾ç½® markdown_template_id 102072992_1733378615"
            
            event.reply(config_text.strip())
            return True
        except Exception as e:
            logger.error(f"æ˜¾ç¤ºé…ç½®å¤±è´¥: {e}")
            event.reply(f'âŒ è·å–é…ç½®å¤±è´¥: {str(e)}')
            return True
    
    @classmethod
    def set_config(cls, event):
        """æŒ‡ä»¤ï¼šä»£å‘è®¾ç½® <é…ç½®é¡¹> <å€¼>"""
        try:
            key = event.matches[0] if event.matches else None
            value_str = event.matches[1] if len(event.matches) > 1 else None
            
            if not key or not value_str:
                event.reply('âŒ å‚æ•°é”™è¯¯\nç”¨æ³•: ä»£å‘è®¾ç½® <é…ç½®é¡¹> <å€¼>')
                return True
            
            # å…è®¸è®¾ç½®çš„é…ç½®é¡¹
            allowed_keys = {
                'enabled': bool,
                'auto_activate': bool,
                'fallback_to_onebot': bool,
                'send_mode': int,
                'markdown_template_id': str,
                'use_callback_mode': bool,
                'callback_trigger_mode': int,
                'callback_markdown_template_id': str,
                'callback_button_template_id': str
            }
            
            if key not in allowed_keys:
                event.reply(f'âŒ ä¸æ”¯æŒçš„é…ç½®é¡¹: {key}\n'
                          f'æ”¯æŒçš„é…ç½®é¡¹: {", ".join(allowed_keys.keys())}')
                return True
            
            # ç±»å‹è½¬æ¢
            value_type = allowed_keys[key]
            try:
                if value_type == bool:
                    value = value_str.lower() in ['true', '1', 'yes', 'on', 'æ˜¯', 'å¯ç”¨']
                elif value_type == int:
                    value = int(value_str)
                    # éªŒè¯send_modeèŒƒå›´
                    if key == 'send_mode' and value not in [1, 2, 3, 4]:
                        event.reply('âŒ å‘é€æ¨¡å¼å¿…é¡»æ˜¯ 1-4\n1=æ™®é€šæ¶ˆæ¯, 2=MarkdownåŸç”Ÿ, 3=AJæ¨¡æ¿, 4=Markdownæ¨¡æ¿')
                        return True
                    # éªŒè¯callback_trigger_modeèŒƒå›´
                    if key == 'callback_trigger_mode' and value not in [1, 2, 3]:
                        event.reply('âŒ å›è°ƒè§¦å‘æ¨¡å¼å¿…é¡»æ˜¯ 1-3\n1=åŸç”Ÿmarkdown+åŸç”ŸæŒ‰é’®, 2=AJæ¨¡æ¿+åŸç”ŸæŒ‰é’®, 3=æ¨¡æ¿markdown+æ¨¡æ¿æŒ‰é’®')
                        return True
                else:
                    value = value_str
            except:
                event.reply(f'âŒ å€¼æ ¼å¼é”™è¯¯ï¼Œ{key} åº”ä¸º {value_type.__name__} ç±»å‹')
                return True
            
            # ä¿å­˜é…ç½®
            config = cls._load_config()
            config[key] = value
            
            if cls._save_config(config):
                event.reply(f'âœ… é…ç½®å·²æ›´æ–°\nâ€¢ {key} = {value}')
            else:
                event.reply('âŒ ä¿å­˜é…ç½®å¤±è´¥')
            
            return True
        except Exception as e:
            logger.error(f"è®¾ç½®é…ç½®å¤±è´¥: {e}")
            event.reply(f'âŒ è®¾ç½®å¤±è´¥: {str(e)}')
            return True
    
    @classmethod
    def check_status(cls, event):
        """æŒ‡ä»¤ï¼šä»£å‘çŠ¶æ€"""
        try:
            config = cls._load_config()
            qq = config.get('official_bot_qq')
            api = config.get('official_bot_api', 'http://127.0.0.1:5001')
            
            if not qq:
                event.reply('âŒ æœªç»‘å®šå®˜æ–¹æœºå™¨äºº\nä½¿ç”¨"ä»£å‘ç»‘å®š <QQå·>"è¿›è¡Œç»‘å®š')
                return True
            
            # æŸ¥è¯¢å®˜æ–¹æœºå™¨äººçŠ¶æ€
            try:
                api_url = f"{api}/web/api/plugin/forward_bridge/status"
                params = {'group_id': event.group_id} if event.is_group else {}
                
                # æ·»åŠ token
                if config.get('use_token', False):
                    token = config.get('token')
                    if token:
                        params['token'] = token
                
                with httpx.Client(timeout=5) as client:
                    response = client.get(api_url, params=params)
                    
                    if response.status_code == 200:
                        data = response.json()
                        if data.get('success'):
                            status_data = data.get('data', {})
                            has_valid = status_data.get('has_valid_message_id', False)
                            remaining = status_data.get('remaining_count', 0)
                            remaining_time = status_data.get('remaining_time', 0)
                            
                            status_text = f"""ğŸ“Š è”åˆä»£å‘çŠ¶æ€

ğŸ¤– å®˜æ–¹æœºå™¨äºº: {qq}
{'ğŸ“ å½“å‰ç¾¤: ' + event.group_id if event.is_group else ''}

{'âœ… çŠ¶æ€: å¯ç”¨' if has_valid else 'âŒ çŠ¶æ€: éœ€è¦æ¿€æ´»'}
{'ğŸ“® å‰©ä½™æ¬¡æ•°: ' + str(remaining) + '/5' if has_valid else ''}
{'â° å‰©ä½™æ—¶é—´: ' + str(int(remaining_time)) + 'ç§’' if has_valid else ''}
"""
                            event.reply(status_text.strip())
                        else:
                            event.reply(f'âœ… å·²ç»‘å®š: {qq}\nâš ï¸ æ— æ³•æŸ¥è¯¢çŠ¶æ€: {data.get("message")}')
                    else:
                        event.reply(f'âœ… å·²ç»‘å®š: {qq}\nâš ï¸ API è¿æ¥å¤±è´¥ (HTTP {response.status_code})')
            except Exception as e:
                event.reply(f'âœ… å·²ç»‘å®š: {qq}\nâš ï¸ æŸ¥è¯¢å¤±è´¥: {str(e)}')
            
            return True
        except Exception as e:
            logger.error(f"çŠ¶æ€æŸ¥è¯¢å¤±è´¥: {e}")
            event.reply(f'âŒ æŸ¥è¯¢å¤±è´¥: {str(e)}')
            return True
    
    # ==================== æ ¸å¿ƒè½¬å‘åŠŸèƒ½ ====================
    
    @classmethod
    def handle_forward(cls, event, content, method_name='reply') -> Optional[str]:
        """å¤„ç†ä»£å‘è¯·æ±‚"""
        if method_name != 'reply' or not event.is_group:
            return None
        
        config = cls._load_config()
        
        if not config.get('enabled', True):
            return None
        
        qq = config.get('official_bot_qq')
        if not qq:
            return None
        
        text_content = cls._extract_text(content)
        
        # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨å›è°ƒæ¨¡å¼
        if config.get('use_callback_mode', False):
            # å›è°ƒæ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°event_id
            group_bindings = config.get('group_callback_bindings', {})
            if event.group_id in group_bindings:
                # å·²ç»‘å®šæŒ‰é’®ä¿¡æ¯ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°event_id
                if cls._should_activate_callback(event.group_id, config):
                    # event_idå·²å¤±æ•ˆï¼Œé‡æ–°å‘é€å›è°ƒåŒ…
                    cls._send_callback_packet(event.group_id, config)
                    time.sleep(0.15)
            else:
                # æœªç»‘å®šæŒ‰é’®ä¿¡æ¯ï¼Œéœ€è¦å…ˆå‘é€å›è°ƒå‘½ä»¤æ¿€æ´»
                cls._activate_official_bot(event.group_id, qq, config)
                
                # é‡æ–°åŠ è½½é…ç½®ï¼Œæ£€æŸ¥æ˜¯å¦å·²ç»æå–åˆ°æŒ‰é’®ä¿¡æ¯
                config = cls._load_config()
                group_bindings = config.get('group_callback_bindings', {})
                if event.group_id in group_bindings:
                    # æå–æˆåŠŸï¼Œå‘é€å›è°ƒåŒ…è·å–event_id
                    cls._send_callback_packet(event.group_id, config)
                    time.sleep(0.15)
        else:
            # æ™®é€šæ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦æ¿€æ´»
            if cls._should_activate(event.group_id, config):
                cls._activate_official_bot(event.group_id, qq, config)
        
        # è½¬å‘æ¶ˆæ¯
        result = cls._forward_to_official(event, text_content, config)
        
        if result and result.get('success'):
            return result.get('message_id')
        
        # è½¬å‘å¤±è´¥ï¼Œæ£€æŸ¥æ˜¯å¦å›é€€
        if not config.get('fallback_to_onebot', True):
            return None
        
        return None
    
    @classmethod
    def _extract_text(cls, content) -> str:
        """æå–æ–‡æœ¬å†…å®¹"""
        if isinstance(content, str):
            return content
        elif isinstance(content, Message):
            return content.extract_plain_text()
        else:
            return str(content)
    
    @classmethod
    def _should_activate(cls, group_id: str, config: dict) -> bool:
        """æ£€æŸ¥æ˜¯å¦éœ€è¦æ¿€æ´»ï¼ˆæ™®é€šæ¨¡å¼ï¼‰"""
        if not config.get('auto_activate', True):
            return False
        
        try:
            api = config.get('official_bot_api', 'http://127.0.0.1:5001')
            api_url = f"{api}/web/api/plugin/forward_bridge/status"
            
            params = {'group_id': group_id}
            if config.get('use_token', False):
                token = config.get('token')
                if token:
                    params['token'] = token
            
            with httpx.Client(timeout=3) as client:
                response = client.get(api_url, params=params)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        has_valid = data.get('data', {}).get('has_valid_message_id', False)
                        if has_valid:
                            return False
        except:
            pass
        
        return True
    
    @classmethod
    def _should_activate_callback(cls, group_id: str, config: dict) -> bool:
        """æ£€æŸ¥å›è°ƒæ¨¡å¼æ˜¯å¦éœ€è¦åˆ·æ–°event_id"""
        try:
            api = config.get('official_bot_api', 'http://127.0.0.1:5001')
            api_url = f"{api}/web/api/plugin/forward_bridge/status"
            
            params = {'group_id': group_id}
            if config.get('use_token', False):
                token = config.get('token')
                if token:
                    params['token'] = token
            
            with httpx.Client(timeout=2) as client:
                response = client.get(api_url, params=params)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        has_valid = data.get('data', {}).get('has_valid_message_id', False)
                        # å¦‚æœæœ‰æœ‰æ•ˆçš„event_idï¼Œä¸éœ€è¦åˆ·æ–°
                        return not has_valid
        except:
            pass
        
        # å¦‚æœæŸ¥è¯¢å¤±è´¥ï¼Œä¸ºäº†ä¿é™©èµ·è§ï¼Œå°è¯•åˆ·æ–°
        return True
    
    @classmethod
    def _activate_official_bot(cls, group_id: str, qq: str, config: dict) -> bool:
        """æ¿€æ´»å®˜æ–¹æœºå™¨äºº"""
        try:
            # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨å›è°ƒæ¨¡å¼
            use_callback_mode = config.get('use_callback_mode', False)
            
            if use_callback_mode:
                # å›è°ƒæ¨¡å¼ï¼šå‘é€ "å›è°ƒ+æ¨¡å¼+æ¨¡æ¿ID"
                callback_mode = config.get('callback_trigger_mode', 1)
                callback_md_template = config.get('callback_markdown_template_id', '')
                callback_btn_template = config.get('callback_button_template_id', '')
                
                # æ„é€ å›è°ƒå‘½ä»¤
                if callback_mode == 1:
                    callback_cmd = "å›è°ƒ 1"
                elif callback_mode == 2:
                    callback_cmd = f"å›è°ƒ 2 {callback_md_template}" if callback_md_template else "å›è°ƒ 2"
                elif callback_mode == 3:
                    if callback_md_template and callback_btn_template:
                        callback_cmd = f"å›è°ƒ 3 {callback_md_template} {callback_btn_template}"
                    else:
                        callback_cmd = "å›è°ƒ 3"
                else:
                    callback_cmd = "å›è°ƒ 1"
                
                logger.info(f"ğŸ”„ å‘é€å›è°ƒå‘½ä»¤ (ç¾¤: {group_id}, å‘½ä»¤: {callback_cmd})")
                
                at_msg = Message([
                    MessageSegment.at(qq),
                    MessageSegment.text(f" {callback_cmd}")
                ])
            else:
                # æ™®é€šæ¨¡å¼ï¼šå‘é€ "ä»£å‘idåˆ·æ–°"
                logger.info(f"ğŸ”„ åˆ·æ–°ä»£å‘ID (ç¾¤: {group_id})")
                
                at_msg = Message([
                    MessageSegment.at(qq),
                    MessageSegment.text(" ä»£å‘idåˆ·æ–°")
                ])
            
            api = get_onebot_api()
            result = run_async_api(api.send_group_msg(group_id, at_msg.to_onebot_array()))
            
            if result and result.get('retcode') == 0:
                # è·å–æ¶ˆæ¯IDå¹¶ç«‹å³æ’¤å›
                message_id = result.get('data', {}).get('message_id')
                if message_id:
                    time.sleep(0.02)
                    run_async_api(api.delete_msg(message_id))
                
                # å¦‚æœæ˜¯å›è°ƒæ¨¡å¼ï¼Œä¸»åŠ¨æå–æŒ‰é’®ä¿¡æ¯
                if use_callback_mode:
                    time.sleep(1)
                    cls._extract_button_from_recent_messages(group_id, qq, config)
                else:
                    time.sleep(0.3)
                
                logger.info(f"âœ… å·²å‘é€æ¿€æ´»å‘½ä»¤ (ç¾¤: {group_id})")
                return True
            
            return False
        except Exception as e:
            logger.error(f"æ¿€æ´»å¼‚å¸¸: {e}")
            return False
    
    @classmethod
    def _forward_to_official(cls, event, content: str, config: dict) -> Optional[dict]:
        """è½¬å‘æ¶ˆæ¯åˆ°å®˜æ–¹æœºå™¨äºº"""
        try:
            api = config.get('official_bot_api', 'http://127.0.0.1:5001')
            api_url = f"{api}/web/api/plugin/forward_bridge/receive"
            
            send_mode = config.get('send_mode', 1)
            
            # æ„å»ºåŸºç¡€æ•°æ®
            forward_data = {
                'group_id': event.group_id,
                'user_id': event.user_id,
                'onebot_message_id': event.message_id
            }
            
            # æ ¹æ®å‘é€æ¨¡å¼æ„å»ºpayload
            if send_mode == 1:
                # æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                forward_data['msg_type'] = 0
                forward_data['content'] = content
            elif send_mode == 2:
                # MarkdownåŸç”Ÿ
                forward_data['msg_type'] = 2
                forward_data['markdown'] = {'content': content}
            elif send_mode in [3, 4]:
                # AJæ¨¡æ¿ æˆ– Markdownæ¨¡æ¿
                forward_data['msg_type'] = 2
                template_id = config.get('markdown_template_id')
                if not template_id:
                    logger.error("æœªé…ç½® markdown_template_id")
                    return None
                forward_data['markdown'] = {
                    'custom_template_id': template_id,
                    'params': [{'key': 'text', 'values': [content]}]
                }
            
            if config.get('use_token', False):
                token = config.get('token')
                if token:
                    forward_data['token'] = token
            
            with httpx.Client(timeout=10) as client:
                response = client.post(api_url, json=forward_data)
                
                if response.status_code == 200:
                    return response.json()
                
                return None
        except Exception as e:
            logger.error(f"è½¬å‘å¼‚å¸¸: {e}")
            return None
    
    # ==================== Web é¢æ¿åŠŸèƒ½ ====================
    
    @classmethod
    def render_page(cls):
        """æ¸²æŸ“Webé…ç½®é¡µé¢"""
        
        # CSS æ ·å¼
        css = """
        .config-container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
        }
        .config-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .config-section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .form-group.vertical {
            flex-direction: column;
            align-items: flex-start;
        }
        .form-group.checkbox-row {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            gap: 30px;
            flex-wrap: wrap;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        .config-label {
            font-weight: 600;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 300px;
            flex-shrink: 0;
        }
        .config-label .label-name {
            flex-shrink: 0;
            font-size: 0.95rem;
            color: #667eea;
            white-space: nowrap;
        }
        .config-label .label-comment {
            font-size: 0.85rem;
            color: #718096;
            font-weight: 400;
            white-space: nowrap;
        }
        .form-group input,
        .form-group select {
            flex: 1;
            min-width: 0;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #007bff;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: auto;
        }
        .checkbox-row .checkbox-group {
            min-width: auto;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            flex-shrink: 0;
        }
        .checkbox-group label {
            margin: 0;
            white-space: nowrap;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .alert {
            padding: 12px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .alert-error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        .status-enabled {
            background-color: #d4edda;
            color: #155724;
        }
        .status-disabled {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        /* å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            .config-container {
                max-width: 100%;
                padding: 10px;
            }
            .form-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .form-group.checkbox-row {
                flex-direction: row;
                gap: 15px;
            }
            .config-label {
                min-width: auto;
                width: 100%;
            }
            .form-group input,
            .form-group select {
                width: 100%;
            }
            .checkbox-group {
                min-width: auto;
            }
        }
        """
        
        # HTML å†…å®¹
        html = """
    <div class="config-container">
        <div id="alert" class="alert"></div>
        
        <div class="config-section">
            <!-- å¼€å…³é€‰é¡¹æ”¾åœ¨ä¸€è¡Œ -->
            <div class="form-group checkbox-row">
                <div class="checkbox-group">
                    <input type="checkbox" id="enabled">
                    <label for="enabled">å¯ç”¨è”åˆä»£å‘</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="auto_activate">
                    <label for="auto_activate">è‡ªåŠ¨æ¿€æ´»</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="fallback_to_onebot">
                    <label for="fallback_to_onebot">å¤±è´¥å›é€€</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="use_token">
                    <label for="use_token">Tokenè®¤è¯</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="use_callback_mode">
                    <label for="use_callback_mode">å›è°ƒæ¨¡å¼</label>
                </div>
            </div>
            
            <!-- è¾“å…¥æ¡†é…ç½® -->
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">å®˜æ–¹æœºå™¨äºº QQ å·:</span>
                </div>
                <input type="text" id="official_bot_qq" placeholder="ä¾‹å¦‚: 3889015568">
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">å®˜æ–¹æœºå™¨äºº API åœ°å€:</span>
                </div>
                <input type="text" id="official_bot_api" placeholder="ä¾‹å¦‚: http://127.0.0.1:5001">
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">æ¶ˆæ¯å‘é€æ¨¡å¼:</span>
                </div>
                <select id="send_mode">
                    <option value="1">1 - æ™®é€šæ–‡æœ¬æ¶ˆæ¯</option>
                    <option value="2">2 - Markdown åŸç”Ÿ</option>
                    <option value="3">3 - AJ æ¨¡æ¿</option>
                    <option value="4">4 - Markdown æ¨¡æ¿</option>
                </select>
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">Markdown æ¨¡æ¿ ID:</span>
                </div>
                <input type="text" id="markdown_template_id" placeholder="ä¾‹å¦‚: 102072992_1733378615">
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">è®¿é—® Token:</span>
                </div>
                <input type="password" id="token" placeholder="ç•™ç©ºåˆ™ä½¿ç”¨å®˜æ–¹æœºå™¨äººçš„ access_token">
            </div>
            
            <!-- å›è°ƒæ¨¡å¼é…ç½® -->
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">å›è°ƒè§¦å‘æ¨¡å¼:</span>
                </div>
                <select id="callback_trigger_mode">
                    <option value="1">1 - åŸç”Ÿ Markdown + åŸç”ŸæŒ‰é’®</option>
                    <option value="2">2 - AJ æ¨¡æ¿ + åŸç”ŸæŒ‰é’®</option>
                    <option value="3">3 - æ¨¡æ¿ Markdown + æ¨¡æ¿æŒ‰é’®</option>
                </select>
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">å›è°ƒ Markdown æ¨¡æ¿ ID:</span>
                </div>
                <input type="text" id="callback_markdown_template_id" placeholder="ä¾‹å¦‚: 102072992_1733378615 (æ¨¡å¼2å’Œ3éœ€è¦)">
            </div>
            
            <div class="form-group">
                <div class="config-label">
                    <span class="label-name">å›è°ƒæŒ‰é’®æ¨¡æ¿ ID:</span>
                </div>
                <input type="text" id="callback_button_template_id" placeholder="ä¾‹å¦‚: 102134274 (æ¨¡å¼3éœ€è¦)">
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button class="btn btn-primary" id="saveBtn">ğŸ’¾ ä¿å­˜é…ç½®</button>
        </div>
        
        <!-- ä½¿ç”¨è¯´æ˜ -->
        <div class="config-section" style="margin-top: 20px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);">
            <h3 style="color: #1976d2;">ğŸ“– å›è°ƒæ¨¡å¼ä½¿ç”¨è¯´æ˜</h3>
            <div style="line-height: 1.8; color: #424242;">
                <p><strong>ğŸ”„ å›è°ƒæ¨¡å¼ä¼˜åŠ¿ï¼š</strong></p>
                <ul>
                    <li>âœ… ä¸€æ¬¡é…ç½®ï¼Œæ°¸ä¹…ä½¿ç”¨ï¼ˆæ¯ä¸ªç¾¤é…ç½®ä¸€æ¬¡ï¼‰</li>
                    <li>âœ… æ— éœ€åˆ·æ–°IDï¼ˆä¸ç”¨å†@æœºå™¨äººåˆ·æ–°ï¼‰</li>
                    <li>âœ… å®Œå…¨è‡ªåŠ¨åŒ–ï¼ˆè‡ªåŠ¨é€šè¿‡å›è°ƒåŒ…è·å–event_idï¼‰</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>ğŸ“‹ ä½¿ç”¨æ­¥éª¤ï¼š</strong></p>
                <ol>
                    <li><strong>å¯ç”¨å›è°ƒæ¨¡å¼ï¼š</strong>å‹¾é€‰ä¸Šæ–¹çš„"å›è°ƒæ¨¡å¼"å¤é€‰æ¡†</li>
                    <li><strong>é€‰æ‹©è§¦å‘æ¨¡å¼ï¼š</strong>
                        <ul style="margin-left: 20px;">
                            <li>æ¨¡å¼1ï¼šåŸç”ŸMarkdown + åŸç”ŸæŒ‰é’®ï¼ˆæœ€ç®€å•ï¼‰</li>
                            <li>æ¨¡å¼2ï¼šAJæ¨¡æ¿ + åŸç”ŸæŒ‰é’®ï¼ˆéœ€æä¾›MDæ¨¡æ¿IDï¼‰</li>
                            <li>æ¨¡å¼3ï¼šæ¨¡æ¿Markdown + æ¨¡æ¿æŒ‰é’®ï¼ˆéœ€æä¾›MDå’ŒæŒ‰é’®æ¨¡æ¿IDï¼‰</li>
                        </ul>
                    </li>
                    <li><strong>åœ¨ç¾¤é‡Œè§¦å‘ï¼š</strong>åœ¨QQç¾¤ä¸­ @å®˜æ–¹æœºå™¨äºº å‘é€ <code>å›è°ƒ 1</code>ï¼ˆæˆ–2/3ï¼‰</li>
                    <li><strong>è‡ªåŠ¨æå–ï¼š</strong>OneBotè‡ªåŠ¨ç›‘æ§å¹¶æå–æŒ‰é’®ä¿¡æ¯</li>
                    <li><strong>åç»­ä½¿ç”¨ï¼š</strong>æ¯æ¬¡å‘æ¶ˆæ¯è‡ªåŠ¨å‘é€å›è°ƒåŒ…è·å–event_id</li>
                </ol>
                
                <p style="margin-top: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                    <strong>ğŸ’¡ æç¤ºï¼š</strong>å›è°ƒæ¨¡å¼é€‚åˆé•¿æœŸä½¿ç”¨çš„ç¾¤ï¼Œé…ç½®ä¸€æ¬¡åæ— éœ€å†æ‰‹åŠ¨åˆ·æ–°IDã€‚
                </p>
            </div>
        </div>
    </div>
        """
        
        # JavaScript ä»£ç 
        script = """
(function() {
    'use strict';
    
    // ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸ
    window.loadConfig = async function() {
        try {
            // æ„å»ºå¸¦ token çš„ URL
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const apiUrl = token 
                ? `/web/api/plugin/forward_bridge/config?token=${token}`
                : '/web/api/plugin/forward_bridge/config';
            
            const response = await fetch(apiUrl);
            const data = await response.json();
            
            if (data.success) {
                const config = data.data;
                
                // æ˜¾ç¤ºé…ç½®æ¥æºä¿¡æ¯
                console.log('=== é…ç½®åŠ è½½ä¿¡æ¯ ===');
                console.log('é…ç½®æ–‡ä»¶è·¯å¾„:', config._config_file);
                console.log('æ–‡ä»¶æ˜¯å¦å­˜åœ¨:', config._file_exists);
                console.log('å®Œæ•´é…ç½®æ•°æ®:', config);
                console.log('==================');
                
                // åŸºç¡€é…ç½®
                document.getElementById('enabled').checked = config.enabled !== false;
                document.getElementById('official_bot_qq').value = config.official_bot_qq || '';
                document.getElementById('official_bot_api').value = config.official_bot_api || 'http://127.0.0.1:5001';
                
                // å‘é€æ¨¡å¼é…ç½®
                document.getElementById('send_mode').value = String(config.send_mode || 1);
                document.getElementById('markdown_template_id').value = config.markdown_template_id || '';
                
                // åŠŸèƒ½é…ç½®
                document.getElementById('auto_activate').checked = config.auto_activate !== false;
                document.getElementById('fallback_to_onebot').checked = config.fallback_to_onebot !== false;
                
                // å®‰å…¨é…ç½®
                document.getElementById('use_token').checked = config.use_token || false;
                document.getElementById('token').value = config.token || '';
                
                // å›è°ƒæ¨¡å¼é…ç½®
                document.getElementById('use_callback_mode').checked = config.use_callback_mode || false;
                document.getElementById('callback_trigger_mode').value = String(config.callback_trigger_mode || 1);
                document.getElementById('callback_markdown_template_id').value = config.callback_markdown_template_id || '';
                document.getElementById('callback_button_template_id').value = config.callback_button_template_id || '';
            } else {
                window.showAlert('åŠ è½½é…ç½®å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
            }
        } catch (error) {
            console.error('åŠ è½½é…ç½®å¼‚å¸¸:', error);
            window.showAlert('åŠ è½½é…ç½®å¤±è´¥: ' + error.message, 'error');
        }
    };
    
    // ä¿å­˜é…ç½®
    window.saveConfig = async function() {
        const config = {
            enabled: document.getElementById('enabled').checked,
            official_bot_qq: document.getElementById('official_bot_qq').value.trim() || null,
            official_bot_api: document.getElementById('official_bot_api').value.trim(),
            send_mode: parseInt(document.getElementById('send_mode').value),
            markdown_template_id: document.getElementById('markdown_template_id').value.trim() || null,
            auto_activate: document.getElementById('auto_activate').checked,
            fallback_to_onebot: document.getElementById('fallback_to_onebot').checked,
            use_token: document.getElementById('use_token').checked,
            token: document.getElementById('token').value.trim() || null,
            use_callback_mode: document.getElementById('use_callback_mode').checked,
            callback_trigger_mode: parseInt(document.getElementById('callback_trigger_mode').value),
            callback_markdown_template_id: document.getElementById('callback_markdown_template_id').value.trim() || null,
            callback_button_template_id: document.getElementById('callback_button_template_id').value.trim() || null
        };
        
        // éªŒè¯
        if (config.send_mode >= 3 && !config.markdown_template_id) {
            window.showAlert('ä½¿ç”¨æ¨¡æ¿æ¨¡å¼æ—¶å¿…é¡»é…ç½® Markdown æ¨¡æ¿ ID', 'error');
            return;
        }
        
        // éªŒè¯å›è°ƒæ¨¡å¼é…ç½®
        if (config.use_callback_mode) {
            if (config.callback_trigger_mode >= 2 && !config.callback_markdown_template_id) {
                window.showAlert('å›è°ƒæ¨¡å¼2å’Œ3éœ€è¦é…ç½® Markdown æ¨¡æ¿ ID', 'error');
                return;
            }
            if (config.callback_trigger_mode === 3 && !config.callback_button_template_id) {
                window.showAlert('å›è°ƒæ¨¡å¼3éœ€è¦é…ç½®æŒ‰é’®æ¨¡æ¿ ID', 'error');
                return;
            }
        }
        
        try {
            // æ„å»ºå¸¦ token çš„ URL
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const apiUrl = token 
                ? `/web/api/plugin/forward_bridge/config?token=${token}`
                : '/web/api/plugin/forward_bridge/config';
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            });
            
            const data = await response.json();
            
            if (data.success) {
                window.showAlert('âœ… é…ç½®ä¿å­˜æˆåŠŸï¼å·²å†™å…¥æœåŠ¡å™¨æ–‡ä»¶', 'success');
                console.log('é…ç½®å·²ä¿å­˜åˆ°æœåŠ¡å™¨:', config);
                console.log('æœåŠ¡å™¨å“åº”:', data);
            } else {
                window.showAlert('ä¿å­˜å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
            }
        } catch (error) {
            console.error('ä¿å­˜é…ç½®å¼‚å¸¸:', error);
            window.showAlert('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message, 'error');
        }
    };
    
    // æ˜¾ç¤ºæç¤º
    window.showAlert = function(message, type) {
        const alert = document.getElementById('alert');
        alert.textContent = message;
        alert.className = 'alert alert-' + type;
        alert.style.display = 'block';
        
        setTimeout(() => {
            alert.style.display = 'none';
        }, 3000);
    };
    
    // åˆå§‹åŒ–å‡½æ•°
    function init() {
        // ç»‘å®šä¿å­˜æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) {
            saveBtn.addEventListener('click', window.saveConfig);
            console.log('ä¿å­˜æŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
        } else {
            console.error('æœªæ‰¾åˆ°ä¿å­˜æŒ‰é’®');
        }
        
        // åŠ è½½é…ç½®
        window.loadConfig();
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    
})(); // ç«‹å³æ‰§è¡Œå‡½æ•°ç»“æŸ
        """
        
        # è¿”å›åˆ†ç¦»çš„ HTMLã€CSSã€JavaScript
        return {
            'html': html,
            'css': css,
            'script': script
        }
    
    @classmethod
    def api_handle_config(cls, request_data=None):
        """API: ç»Ÿä¸€å¤„ç†é…ç½®è¯·æ±‚ï¼ˆGET/POSTï¼‰"""
        from flask import request
        
        if request.method == 'GET':
            return cls.api_get_config(request_data)
        elif request.method == 'POST':
            return cls.api_update_config(request_data)
        else:
            return {
                'success': False,
                'message': f'ä¸æ”¯æŒçš„è¯·æ±‚æ–¹æ³•: {request.method}'
            }
    
    @classmethod
    def api_get_config(cls, request_data=None):
        """API: è·å–é…ç½®"""
        try:
            # å¼ºåˆ¶ä»æ–‡ä»¶é‡æ–°åŠ è½½é…ç½®
            config_file = os.path.join(os.path.dirname(__file__), 'forward_config.json')
            logger.info(f"è¯»å–é…ç½®æ–‡ä»¶: {config_file}")
            
            config = cls._load_config()
            
            # æ·»åŠ é…ç½®æ–‡ä»¶è·¯å¾„ä¿¡æ¯ç”¨äºè°ƒè¯•
            config['_config_file'] = config_file
            config['_file_exists'] = os.path.exists(config_file)
            
            logger.info(f"é…ç½®è¯»å–æˆåŠŸ: {config}")
            
            return {
                'success': True,
                'data': config,
                'message': 'é…ç½®åŠ è½½è‡ªæœåŠ¡å™¨æ–‡ä»¶'
            }
        except Exception as e:
            logger.error(f"è·å–é…ç½®å¤±è´¥: {e}")
            return {
                'success': False,
                'message': f'è·å–é…ç½®å¤±è´¥: {str(e)}'
            }
    
    @classmethod
    def api_update_config(cls, request_data=None):
        """API: æ›´æ–°é…ç½®"""
        try:
            if not request_data:
                return {
                    'success': False,
                    'message': 'ç¼ºå°‘é…ç½®æ•°æ®'
                }
            
            logger.info(f"æ”¶åˆ°é…ç½®æ›´æ–°è¯·æ±‚: {request_data}")
            
            # éªŒè¯send_mode
            send_mode = request_data.get('send_mode', 1)
            if send_mode not in [1, 2, 3, 4]:
                return {
                    'success': False,
                    'message': 'å‘é€æ¨¡å¼å¿…é¡»æ˜¯ 1-4'
                }
            
            # éªŒè¯æ¨¡æ¿ID
            if send_mode >= 3 and not request_data.get('markdown_template_id'):
                return {
                    'success': False,
                    'message': 'ä½¿ç”¨æ¨¡æ¿æ¨¡å¼æ—¶å¿…é¡»é…ç½® Markdown æ¨¡æ¿ ID'
                }
            
            # éªŒè¯å›è°ƒæ¨¡å¼é…ç½®
            if request_data.get('use_callback_mode', False):
                callback_trigger_mode = request_data.get('callback_trigger_mode', 1)
                if callback_trigger_mode >= 2 and not request_data.get('callback_markdown_template_id'):
                    return {
                        'success': False,
                        'message': 'å›è°ƒæ¨¡å¼2å’Œ3éœ€è¦é…ç½® Markdown æ¨¡æ¿ ID'
                    }
                if callback_trigger_mode == 3 and not request_data.get('callback_button_template_id'):
                    return {
                        'success': False,
                        'message': 'å›è°ƒæ¨¡å¼3éœ€è¦é…ç½®æŒ‰é’®æ¨¡æ¿ ID'
                    }
            
            # è·å–é…ç½®æ–‡ä»¶è·¯å¾„
            config_file = os.path.join(os.path.dirname(__file__), 'forward_config.json')
            
            # ä¿å­˜é…ç½®
            if cls._save_config(request_data):
                logger.info(f"é…ç½®å·²ä¿å­˜åˆ°: {config_file}")
                return {
                    'success': True,
                    'message': f'é…ç½®ä¿å­˜æˆåŠŸï¼Œå·²å†™å…¥: {config_file}'
                }
            else:
                logger.error(f"é…ç½®ä¿å­˜å¤±è´¥: {config_file}")
                return {
                    'success': False,
                    'message': 'é…ç½®ä¿å­˜å¤±è´¥'
                }
        except Exception as e:
            logger.error(f"æ›´æ–°é…ç½®å¤±è´¥: {e}")
            return {
                'success': False,
                'message': f'æ›´æ–°é…ç½®å¤±è´¥: {str(e)}'
            }
    
    # ==================== å›è°ƒæŒ‰é’®æ¨¡å¼åŠŸèƒ½ ====================
    
    @classmethod
    def _extract_button_from_recent_messages(cls, group_id: str, official_qq: str, config: dict):
        """ä»æœ€è¿‘çš„ç¾¤æ¶ˆæ¯ä¸­æå–å®˜æ–¹æœºå™¨äººå‘é€çš„æŒ‰é’®ä¿¡æ¯"""
        try:
            api = get_onebot_api()
            
            # å°è¯•å¤šæ¬¡è·å–ï¼Œå› ä¸ºæ¶ˆæ¯å¯èƒ½è¿˜æ²¡åˆ°è¾¾
            for attempt in range(2):
                if attempt > 0:
                    time.sleep(0.05)
                
                try:
                    history_result = run_async_api(api.call_api('get_group_msg_history', group_id=int(group_id)))
                    if history_result and history_result.get('retcode') == 0:
                        messages = history_result.get('data', {}).get('messages', [])
                        
                        for msg in messages:
                            sender_id = msg.get('sender', {}).get('user_id')
                            message_id = msg.get('message_id')
                            message_content = msg.get('message', [])
                            
                            if str(sender_id) == str(official_qq):
                                has_markdown = any(isinstance(seg, dict) and seg.get('type') == 'markdown' 
                                                 for seg in (message_content if isinstance(message_content, list) else []))
                                
                                if has_markdown:
                                    class MockEvent:
                                        def __init__(self, group_id, message_id):
                                            self.group_id = group_id
                                            self.message_id = message_id
                                            self.is_group = True
                                    
                                    mock_event = MockEvent(group_id, message_id)
                                    pb_data = cls._get_message_pb(mock_event)
                                    
                                    if pb_data:
                                        button_info = cls._extract_button_info_from_pb(pb_data)
                                        if button_info:
                                            cls._save_callback_config(group_id, button_info, config)
                                            return True
                except:
                    pass
            
            return False
        except:
            return False
    
    @classmethod
    def _save_callback_config(cls, group_id: str, button_info: dict, config: dict):
        """ä¿å­˜å›è°ƒé…ç½®"""
        callback_packet = {
            1: 4398,
            2: 1,
            4: {
                3: button_info['appid'],
                4: random.randint(10000, 99999),
                5: button_info['button_id'],
                6: button_info['bot_token'],
                7: 0,
                8: int(group_id),
                9: 1
            },
            12: 1
        }
        
        group_bindings = config.get('group_callback_bindings', {})
        group_bindings[group_id] = {
            'callback_packet': callback_packet,
            'appid': button_info['appid'],
            'button_id': button_info['button_id'],
            'bot_token': button_info['bot_token'],
            'setup_time': time.time()
        }
        
        config['group_callback_bindings'] = group_bindings
        cls._save_config(config)
    
    
    @classmethod
    def _get_message_pb(cls, event) -> Optional[dict]:
        """è·å–æ¶ˆæ¯çš„PBåŸå§‹æ•°æ®"""
        try:
            real_seq = None
            try:
                from function.log_db import get_log_from_db
                db_msg = get_log_from_db('received', message_id=event.message_id)
                if db_msg:
                    real_seq = db_msg.get('real_seq')
            except:
                pass
            
            if not real_seq:
                api = get_onebot_api()
                msg_info = run_async_api(api.get_msg(event.message_id))
                if msg_info and isinstance(msg_info, dict):
                    real_seq = msg_info.get('data', {}).get('real_seq') if msg_info.get('retcode') == 0 else msg_info.get('real_seq')
            
            if not real_seq:
                return None
            
            packet = {
                1: {
                    1: int(event.group_id),
                    2: int(real_seq),
                    3: int(real_seq)
                },
                2: True
            }
            
            api = get_onebot_api()
            result = run_async_api(api.call_api('send_packet', 
                cmd='trpc.msg.register_proxy.RegisterProxy.SsoGetGroupMsg',
                data=pb.encode(packet).hex()
            ))
            
            if result and isinstance(result, dict):
                response_data = result.get('data')
                if isinstance(response_data, str) and response_data:
                    try:
                        return pb.decode(response_data)
                    except:
                        pass
            return None
        except:
            return None
    
    @classmethod
    def _extract_button_info_from_pb(cls, pb_data: dict) -> Optional[dict]:
        """ä»PBæ•°æ®ä¸­æå–æŒ‰é’®ä¿¡æ¯"""
        try:
            elem_list = pb_data.get(3, {}).get(6, {}).get(3, {}).get(1, {}).get(2, [])
            if not elem_list:
                return None
            
            for elem in elem_list:
                if not isinstance(elem, dict):
                    continue
                
                struct_msg = elem.get(53)
                if not struct_msg or struct_msg.get(1) != 46:
                    continue
                
                button_container = struct_msg.get(2, {}).get(1, {}).get(1, {})
                first_button = button_container.get(1) if isinstance(button_container, dict) else None
                if not first_button:
                    continue
                
                button_id = first_button.get(1)
                action_data = first_button.get(3, {})
                bot_token_raw = action_data.get(5, '')
                if isinstance(bot_token_raw, dict):
                    bot_token_raw = bot_token_raw.get(8, '')
                
                appid = struct_msg.get(2, {}).get(1, {}).get(2)
                
                if not button_id or not appid:
                    continue
                
                bot_token = bot_token_raw
                if isinstance(bot_token, str):
                    if bot_token.startswith('T1.0_'):
                        bot_token = 'BO' + bot_token
                    elif not bot_token.startswith('BO'):
                        bot_token = 'BO' + bot_token
                
                return {
                    'button_id': button_id,
                    'appid': appid,
                    'bot_token': bot_token
                }
            
            return None
        except:
            return None
    
    @classmethod
    def _send_callback_packet(cls, group_id: str, config: dict) -> bool:
        """å‘é€å›è°ƒåŒ…ï¼Œè§¦å‘INTERACTIONäº‹ä»¶"""
        try:
            binding = config.get('group_callback_bindings', {}).get(group_id)
            if not binding:
                return False
            
            stored_packet = binding['callback_packet']
            callback_packet = {
                1: int(stored_packet.get('1', 4398)),
                2: int(stored_packet.get('2', 1)),
                4: {
                    3: int(stored_packet['4']['3']),
                    4: random.randint(10000, 99999),
                    5: stored_packet['4']['5'],
                    6: stored_packet['4']['6'],
                    7: int(stored_packet['4']['7']),
                    8: int(stored_packet['4']['8']),
                    9: int(stored_packet['4']['9'])
                },
                12: int(stored_packet.get('12', 1))
            }
            
            api = get_onebot_api()
            result = run_async_api(api.call_api('send_packet',
                cmd='OidbSvcTrpcTcp.0x112e_1',
                data=pb.encode(callback_packet).hex()
            ))
            
            return bool(result)
        except:
            return False

